% This code was primarily generated by OpenCOR the Cooling et al. 2009
% CellML model provided at the Physiome Repository

% Edited by H Hunt 2020

function [VOI, STATES, ALGEBRAIC, CONSTANTS,model_t,model_ca] = NFAT_Cooling2009(params)
%    global model_t;global model_ca;
   [VOI, STATES, ALGEBRAIC, CONSTANTS,model_t,model_ca] = solveModel(params);
end

function [algebraicVariableCount] = getAlgebraicVariableCount()
    % Used later when setting a global variable with the number of algebraic variables.
    % Note: This is not the "main method".
    algebraicVariableCount =9;
end
% There are a total of 4 entries in each of the rate and state variable arrays.
% There are a total of 16 entries in the constant variable array.
%

function [VOI, STATES, ALGEBRAIC, CONSTANTS,model_t,model_ca] = solveModel(model_params)
    % Create ALGEBRAIC of correct size
    global algebraicVariableCount;  algebraicVariableCount = getAlgebraicVariableCount();
    % Initialise constants and state variables
    [INIT_STATES, CONSTANTS] = initConsts;

    % Set timespan to solve over
    maxt=250*60;
    tspan = [0, maxt];

    % Set numerical accuracy options for ODE solver
    options = odeset('RelTol', 1e-06, 'AbsTol', 1e-06, 'MaxStep', 1);

    % Calculate Ca
%     model_params = [15,10,40,6,10,1,1,1,1,1,1e3];
    [model_time, model_states_full, ~, model_constants] = ECC_ETC_PS(model_params,[]);
    ultimate_transient = model_time>(model_time(end)-model_constants(:,7));
    penultimate_transient = model_time>(model_time(end)-2*model_constants(:,7))&model_time<=(model_time(end)-model_constants(:,7));
    ultimate_transient_cai = model_states_full(ultimate_transient,1);
    penultimate_transient_cai = model_states_full(penultimate_transient,1);
    count=1;
    while (trapz(model_time(ultimate_transient),ultimate_transient_cai)-...
            trapz(model_time(penultimate_transient),penultimate_transient_cai))...
            >1e-2
        [model_time, model_states_full, ~, model_constants] = ECC_ETC_PS(model_params,model_states_full(end,:));
        ultimate_transient = model_time>(model_time(end)-model_constants(:,7));
        penultimate_transient = model_time>(model_time(end)-2*model_constants(:,7))&model_time<=(model_time(end)-model_constants(:,7));
        ultimate_transient_cai = model_states_full(ultimate_transient,1);
        penultimate_transient_cai = model_states_full(penultimate_transient,1);
        count=count+1;
    end
    
%     global model_t;
    num_reps=floor(maxt*1000/model_constants(:,7))+1;
    transient_time=model_time(ultimate_transient);
    model_t = (reshape(repmat(transient_time-transient_time(1),[num_reps,1])',...
        [size(ultimate_transient_cai,1)*num_reps,1])+...
        reshape(repmat((0:model_constants(:,7):((num_reps-1)*model_constants(:,7))),...
        [size(ultimate_transient_cai),1]),[size(ultimate_transient_cai,1)*num_reps,1]))/1000;
%     global model_ca;
    model_ca=repmat(ultimate_transient_cai,[num_reps,1])*1e6;
    % Solve model with ODE solver
    [VOI, STATES] = ode15s(@(VOI, STATES)computeRates(VOI, STATES, CONSTANTS,model_t,model_ca), tspan, INIT_STATES, options);

    % Compute algebraic variables
    [RATES, ALGEBRAIC] = computeRates(VOI, STATES, CONSTANTS,model_t,model_ca);
    ALGEBRAIC = computeAlgebraic(ALGEBRAIC, CONSTANTS, STATES, VOI,model_t,model_ca);

%     % Plot state variables against variable of integration
%     [LEGEND_STATES, LEGEND_ALGEBRAIC, LEGEND_VOI, LEGEND_CONSTANTS] = createLegends();
%     figure();
%     plot(VOI, STATES);
%     xlabel(LEGEND_VOI);
%     l = legend(LEGEND_STATES);
%     set(l,'Interpreter','none');
end

function [LEGEND_STATES, LEGEND_ALGEBRAIC, LEGEND_VOI, LEGEND_CONSTANTS] = createLegends()
    LEGEND_STATES = ''; LEGEND_ALGEBRAIC = ''; LEGEND_VOI = ''; LEGEND_CONSTANTS = '';
    LEGEND_VOI = strpad('t in component environment (s)');
    LEGEND_CONSTANTS(:,1) = strpad('Ccn in component geometry (dimensionless)');
    LEGEND_ALGEBRAIC(:,1) = strpad('nuclearNFAT in component NFAT_Cycling_interface (nM)');
    LEGEND_STATES(:,1) = strpad('NFATN_n in component NFAT_Cycling (nM)');
    LEGEND_STATES(:,2) = strpad('NFATp_n in component NFAT_Cycling (nM)');
    LEGEND_ALGEBRAIC(:,4) = strpad('Ca in component calcium (nM)');
    LEGEND_ALGEBRAIC(:,2) = strpad('ms_in_pulse in component calcium (ms)');
    LEGEND_CONSTANTS(:,2) = strpad('period in component calcium (s)');
    LEGEND_CONSTANTS(:,15) = strpad('baseline in component calcium (nM)');
    LEGEND_CONSTANTS(:,16) = strpad('stimGradient in component calcium (nM_per_ms)');
    LEGEND_ALGEBRAIC(:,3) = strpad('CaBeat in component calcium (nM)');
    LEGEND_CONSTANTS(:,3) = strpad('CaSigTrans in component calcium (nM)');
    LEGEND_CONSTANTS(:,4) = strpad('M in component calcineurin (nM)');
    LEGEND_CONSTANTS(:,5) = strpad('Ntot in component calcineurin (nM)');
    LEGEND_CONSTANTS(:,6) = strpad('K_mN in component calcineurin (nM)');
    LEGEND_CONSTANTS(:,7) = strpad('n in component calcineurin (dimensionless)');
    LEGEND_CONSTANTS(:,8) = strpad('K_dN in component calcineurin (nM)');
    LEGEND_ALGEBRAIC(:,5) = strpad('act_N in component calcineurin (dimensionless)');
    LEGEND_STATES(:,3) = strpad('NFATN_c in component NFAT_Cycling (nM)');
    LEGEND_STATES(:,4) = strpad('NFATp_c in component NFAT_Cycling (nM)');
    LEGEND_CONSTANTS(:,9) = strpad('k_f1 in component NFAT_Cycling (per_nM_s)');
    LEGEND_CONSTANTS(:,10) = strpad('k_r1 in component NFAT_Cycling (per_s)');
    LEGEND_CONSTANTS(:,11) = strpad('k_f2 in component NFAT_Cycling (per_s)');
    LEGEND_CONSTANTS(:,12) = strpad('k_f3 in component NFAT_Cycling (per_s)');
    LEGEND_CONSTANTS(:,13) = strpad('k_r3 in component NFAT_Cycling (per_nM_s)');
    LEGEND_CONSTANTS(:,14) = strpad('k_f4 in component NFAT_Cycling (per_s)');
    LEGEND_ALGEBRAIC(:,6) = strpad('J1 in component NFAT_Cycling (nM_per_s)');
    LEGEND_ALGEBRAIC(:,7) = strpad('J2 in component NFAT_Cycling (nM_per_s)');
    LEGEND_ALGEBRAIC(:,8) = strpad('J3 in component NFAT_Cycling (nM_per_s)');
    LEGEND_ALGEBRAIC(:,9) = strpad('J4 in component NFAT_Cycling (nM_per_s)');
    LEGEND_RATES(:,4) = strpad('d/dt NFATp_c in component NFAT_Cycling (nM)');
    LEGEND_RATES(:,3) = strpad('d/dt NFATN_c in component NFAT_Cycling (nM)');
    LEGEND_RATES(:,1) = strpad('d/dt NFATN_n in component NFAT_Cycling (nM)');
    LEGEND_RATES(:,2) = strpad('d/dt NFATp_n in component NFAT_Cycling (nM)');
    LEGEND_STATES  = LEGEND_STATES';
    LEGEND_ALGEBRAIC = LEGEND_ALGEBRAIC';
    LEGEND_RATES = LEGEND_RATES';
    LEGEND_CONSTANTS = LEGEND_CONSTANTS';
end

function [STATES, CONSTANTS] = initConsts()
    VOI = 0; CONSTANTS = []; STATES = []; ALGEBRAIC = [];
    CONSTANTS(:,1) = 50;
    STATES(:,1) = 0.50910553;
    STATES(:,2) = 0.27638027;
    CONSTANTS(:,2) = 1.02;
    CONSTANTS(:,3) = 0;
    CONSTANTS(:,4) = 6000;
    CONSTANTS(:,5) = 1000;
    CONSTANTS(:,6) = 535;
    CONSTANTS(:,7) = 2.92;
    CONSTANTS(:,8) = 1760;
    STATES(:,3) = 0.0017047398;
    STATES(:,4) = 0.9825855442;
    CONSTANTS(:,9) = 7.68934e-6;
    CONSTANTS(:,10) = 0.019256;
    CONSTANTS(:,11) = 0.00144192;
    CONSTANTS(:,12) = 0.000361944;
    CONSTANTS(:,13) = 4.70813e-5;
    CONSTANTS(:,14) = 0.000444695;
    CONSTANTS(:,15) = piecewise({CONSTANTS(:,2)>=0.120000, 93.0000 }, 1121.00+ ( CONSTANTS(:,2).*1000.00 - 16.0000).* - 9.88460);
    CONSTANTS(:,16) = (1121.00 - CONSTANTS(:,15))./16.0000;
%     STATES=[0.705267474192312,0.346755423421977,0.00219128028633088,0.976768261761414];
    if (isempty(STATES)), warning('Initial values for states not set');, end
end

function [RATES, ALGEBRAIC] = computeRates(VOI, STATES, CONSTANTS,model_t,model_ca)
    global algebraicVariableCount;%global model_ca; global model_t;
    statesSize = size(STATES);
    statesColumnCount = statesSize(2);
    if ( statesColumnCount == 1)
        STATES = STATES';
        ALGEBRAIC = zeros(1, algebraicVariableCount);
        utilOnes = 1;
    else
        statesRowCount = statesSize(1);
        ALGEBRAIC = zeros(statesRowCount, algebraicVariableCount);
        RATES = zeros(statesRowCount, statesColumnCount);
        utilOnes = ones(statesRowCount, 1);
    end
    ALGEBRAIC(:,2) =  1000.00.*(VOI -  floor(VOI./CONSTANTS(:,2)).*CONSTANTS(:,2));
    ALGEBRAIC(:,3) = piecewise({ALGEBRAIC(:,2)<=16.0000,  ALGEBRAIC(:,2).*CONSTANTS(:,16)+CONSTANTS(:,15) , ALGEBRAIC(:,2)>16.0000&ALGEBRAIC(:,2)<=120.000,  (ALGEBRAIC(:,2) - 16.0000).* - 9.88460+1121.00 }, CONSTANTS(:,15));
    ALGEBRAIC(:,4) = interp1q(model_t,model_ca,VOI);%ALGEBRAIC(:,3)+CONSTANTS(:,3);
    ALGEBRAIC(:,5) = power(ALGEBRAIC(:,4), CONSTANTS(:,7))./(power(ALGEBRAIC(:,4), CONSTANTS(:,7))+ power(CONSTANTS(:,6), CONSTANTS(:,7)).*(1.00000+CONSTANTS(:,8)./CONSTANTS(:,4)));
    ALGEBRAIC(:,6) =  CONSTANTS(:,9).*STATES(:,4).*CONSTANTS(:,5).*ALGEBRAIC(:,5) -  CONSTANTS(:,10).*STATES(:,3).*(1.00000 - ALGEBRAIC(:,5));
    ALGEBRAIC(:,7) =  CONSTANTS(:,11).*STATES(:,3);
    RATES(:,3) = ALGEBRAIC(:,6) - ALGEBRAIC(:,7);
    ALGEBRAIC(:,8) =  CONSTANTS(:,12).*STATES(:,1).*(1.00000 - ALGEBRAIC(:,5)) -  CONSTANTS(:,13).*STATES(:,2).*CONSTANTS(:,5).*ALGEBRAIC(:,5);
    RATES(:,1) =  ALGEBRAIC(:,7).*CONSTANTS(:,1) - ALGEBRAIC(:,8);
    ALGEBRAIC(:,9) =  CONSTANTS(:,14).*STATES(:,2);
    RATES(:,4) = ALGEBRAIC(:,9)./CONSTANTS(:,1) - ALGEBRAIC(:,6);
    RATES(:,2) = ALGEBRAIC(:,8) - ALGEBRAIC(:,9);
   RATES = RATES';
end

% Calculate algebraic variables
function ALGEBRAIC = computeAlgebraic(ALGEBRAIC, CONSTANTS, STATES, VOI,model_t,model_ca)
% global model_ca;global model_t;
    statesSize = size(STATES);
    statesColumnCount = statesSize(2);
    if ( statesColumnCount == 1)
        STATES = STATES';
        utilOnes = 1;
    else
        statesRowCount = statesSize(1);
        utilOnes = ones(statesRowCount, 1);
    end
    ALGEBRAIC(:,2) =  1000.00.*(VOI -  floor(VOI./CONSTANTS(:,2)).*CONSTANTS(:,2));
    ALGEBRAIC(:,3) = piecewise({ALGEBRAIC(:,2)<=16.0000,  ALGEBRAIC(:,2).*CONSTANTS(:,16)+CONSTANTS(:,15) , ALGEBRAIC(:,2)>16.0000&ALGEBRAIC(:,2)<=120.000,  (ALGEBRAIC(:,2) - 16.0000).* - 9.88460+1121.00 }, CONSTANTS(:,15));
    ALGEBRAIC(:,4) = interp1q(model_t,model_ca,VOI);;%ALGEBRAIC(:,3)+CONSTANTS(:,3);
    ALGEBRAIC(:,5) = power(ALGEBRAIC(:,4), CONSTANTS(:,7))./(power(ALGEBRAIC(:,4), CONSTANTS(:,7))+ power(CONSTANTS(:,6), CONSTANTS(:,7)).*(1.00000+CONSTANTS(:,8)./CONSTANTS(:,4)));
    ALGEBRAIC(:,6) =  CONSTANTS(:,9).*STATES(:,4).*CONSTANTS(:,5).*ALGEBRAIC(:,5) -  CONSTANTS(:,10).*STATES(:,3).*(1.00000 - ALGEBRAIC(:,5));
    ALGEBRAIC(:,7) =  CONSTANTS(:,11).*STATES(:,3);
    ALGEBRAIC(:,8) =  CONSTANTS(:,12).*STATES(:,1).*(1.00000 - ALGEBRAIC(:,5)) -  CONSTANTS(:,13).*STATES(:,2).*CONSTANTS(:,5).*ALGEBRAIC(:,5);
    ALGEBRAIC(:,9) =  CONSTANTS(:,14).*STATES(:,2);
    ALGEBRAIC(:,1) = STATES(:,1)+STATES(:,2);
end

% Compute result of a piecewise function
function x = piecewise(cases, default)
    set = [0];
    for i = 1:2:length(cases)
        if (length(cases{i+1}) == 1)
            x(cases{i} & ~set,:) = cases{i+1};
        else
            x(cases{i} & ~set,:) = cases{i+1}(cases{i} & ~set);
        end
        set = set | cases{i};
        if(set), break, end
    end
    if (length(default) == 1)
        x(~set,:) = default;
    else
        x(~set,:) = default(~set);
    end
end

% Pad out or shorten strings to a set length
function strout = strpad(strin)
    req_length = 160;
    insize = size(strin,2);
    if insize > req_length
        strout = strin(1:req_length);
    else
        strout = [strin, blanks(req_length - insize)];
    end
end

